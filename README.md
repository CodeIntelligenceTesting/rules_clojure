# Yet Another Clojure rules for [Bazel](https://bazel.build)

Status: pre-release.

## Features
- tools.deps support
- native JVM libraries
- fine-grained dependency analysis
- directory layout flexibility

## Setup

Add the following to your `WORKSPACE`:

```skylark


RULES_CLOJURE_SHA = $CURRENT_SHA1
http_archive(name = "rules_clojure",
             strip_prefix = "rules_clojure-%s" % RULES_CLOJURE_SHA,
             url = "https://github.com/griffinbank/rules_clojure/archive/%s.zip" % RULES_CLOJURE_SHA)

load("@rules_clojure//:repositories.bzl", "rules_clojure_dependencies")
rules_clojure_dependencies()

load("@rules_clojure//:toolchains.bzl", "rules_clojure_default_toolchain")
rules_clojure_default_toolchain()
```

Differs from [rules_clojure](https://github.com/simuons/rules_clojure) that it uses `java_library` and `java_binary` as much as possible.

`clojure_binary`, `clojure_repl` and `clojure_test` are all macros that delegate to `java_binary`. `clojure_library` is new code.

For fast compilation, `clojure_library` is a Bazel persistent worker, which uses protobufs.

```
clojure_library(
    name = "libbbq",
    srcs = ["bbq.clj"],
    deps = ["foo"],
    resource_strip_prefix = ["src"],
    aot = ["foo.bbq"])
```

It is likely you're interested in using Bazel because you have large projects with long compile and or test steps. By default, rules_clojure attempts to AOT as much as possible, for speed.

`clojure_library` produces a jar.

- `srcs` are present on the classpath while AOTing, but the `.clj` is not added to the jar (class files resulting from the AOT will be added to the jar).
- `deps` may be `clojure_library` or any bazel JavaInfo target (`java_library`, etc).
- `aot` is a list of namespaces to compile.
- `resources` are unconditionally added to the jar. `rules_java` expects all code to follow the maven directory layout, and does not support building jars from source files in other locations. To avoid Clojure projects being forced into the maven directory layout, use `resource_strip_prefix`, which behaves the same as in `java_library`.

If you don't need to AOT, `clojure_library` isn't necessary, just use `java_library` with `resource_strip_prefix`.

Because of Clojure's general lack of concern about the difference between runtime and compile-time (e.g. AOT), prefer using `deps` over `runtime_deps`. A downstream library might depend on the library, and whether it's a `dep` or `runtime_dep` depends on whether the downstream library is AOTing or not.

### clojure_repl

```
clojure_repl(
    name = "foo_repl",
    deps = [":foo"])
```

Behaves as you'd expect. Delegates to `java_binary` with `main_class clojure.main`.

### clojure_test

```
clojure_test(name = "bar_test.test",
	test_ns = "foo.bar-test",
	srcs = ["bar_test"])
```

Delegates to `java_test`, using `rules-clojure.testrunner`. Note that bazel defines a test as a script that returns exit code 0, so startup time is relevant. `clojure_test` runs all tests in a single namespace.

## tools.deps dependencies (optional)
```
load("@rules_clojure//rules:tools_deps.bzl", "clojure_tools_deps", "install_clojure_tools_deps")

rules_clojure_dependencies()
rules_clojure_toolchains()

clojure_tools_deps(name = "deps",
                   clj_version = "1.10.1.763",
                   deps_edn = "//:deps.edn",
                   aliases = ["dev", "test"])
```

`clojure_tools_deps` will call `clojure` to resolve dependencies from a deps.edn file and write BUILD files containing `java_import` targets for all dependencies. Targets follow the same naming rules as `rules_jvm_external`, i.e. `@deps//:org_clojure_clojure`.

For each clojure namespace in the library, an additional target will be generated, which produces an AOT jar consisting of a non-transitive compile of just that namespace. The target has the name `@deps//:org_clojure_clojure_clojure_core`, i.e. `$packagename_$namespace`. libraries generated by `gen_src` (below), depend on the per-namespace targets. These per-namespace jars contain only .classfiles, and do not contain any resources in the original jar.

## BUILD generation (optional)

In a BUILD file,
```
load("@rules_clojure//rules:tools_deps.bzl", "clojure_gen_srcs")

clojure_gen_srcs(
    name = "gen_srcs",
    deps_edn = "//:deps.edn",
    aliases = ["dev", "test"],
    deps_repo_tag = "@deps")
```

`gen_srcs` defines a target which behaves similarly to [bazel-gazelle](https://github.com/bazelbuild/bazel-gazelle). When run, it introspects all directories under deps.edn `:paths`, and generates a BUILD.bazel file in each directory. `gen_src` defines `clojure_library` and `clojure_test` targets. Creates a library per namespace, with AOT on.

Run `gen_srcs` again any time the ns declarations in the source tree change.

Adding

```
(ns foo.bbq
  {:bazel/clojure_library {:deps []}}
  (:require ...)
```

Adding the key `:bazel/clojure_library` to the namespace metadata will `merge` any fields into the generated `clojure_library` definition.

### Tests

For files with paths matching `_test.clj`, gen-src defines both a `clojure_library` and `clojure_test`:

```
clojure_library(name = "bar_test",
	srcs = ["bar_test.clj"],
	deps = [...],
	testonly = True)

clojure_test(name = "bar_test.test",
	test_ns = "foo.bar-test",
	deps = ["bar_test"])

```

Because Bazel requires target names to be unique within the same directory, the namespace target always matches the `ns`, while the `test` target is `$ns.test`, so the binary test target is `foo_test.test`. ¯\\\_(ツ)_/¯

```
(ns foo.bar-test
  {:bazel/clojure_test {:jvm_flags []
                        :tags [:integration]
                        :timeout :long}}
  (:require ...)
```

Adding the key `:bazel/clojure_test` to the namespace metadata will `merge` any fields into the generated `clojure_test` definition.


### extra deps

Sometimes the dependency graph isn't complete, for example when using JVM libraries with native libraries, or some APIs that don't utilize `require`, e.g. [cognitect aws api](https://github.com/cognitect-labs/aws-api).

```clojure
:bazel {:deps {"@deps//:com_cognitect_aws_api" {:deps ["@deps//:com_cognitect_aws_endpoints"]}}}
```

put `:bazel {:deps {}}` at the top level of your deps.edn file. `:deps` will be merged in when running `gen_srcs`. Deps are a map of bazel labels to a map of extra fields to merge into the `clojure_library`.

### no AOT

```clojure
:bazel {:no-aot #{foo.bar}}
```

Instructs gen-build to not AOT that namespace

### Coarse dependencies

Fine grained dependencies are ideal from an efficiency perspective, but it isn't always possible to make them work.

`gen_srcs` also creates a few extra targets in every directory on the deps.edn search path. It will produce `clojure_library` targets named `__clj_lib`  and `__cljs_lib` containing all source files in the directory, and all subpackages, and `filegroup` rules named `__clj_files` and `__cljs_files`. ```//src:__clj_files``` includes all src files under `src`, which can be used for e.g. `clojure_repl`. This target is also useful static analysis.

Note `__clj_lib` does not include dependencies. Use `@deps//:__all` to pull in all dependencies. Use `__clj_lib`, `__clj_files` and `@deps//:__all` sparingly, by necessity they will be dirty any time any src file or dependency changes.

## deps.edn options

### :ignore / Resources

You probably want to create your own java_library targets for `resources`.

By default, `resources` is on the tools.deps classpath. By default, `gen_deps` and `gen_srcs` operate on every directory under under `:paths`. When gen-build runs, it will overwrite any existing BUILD.bazel files. To tell gen-build to ignore those libraries:

```clojure
:bazel {:ignore ["//resources", "//test-resources"]}
```

gen-build will not produce BUILD.bazel files for any path under `:ignore`

### :clojure_library and :clojure_test

```clojure
:bazel {:clojure_library {:deps ["//resources:data_readers"]}
        :clojure_test {:jvm_flags ["-Xmx=2g"]}}
```

Any fields under :clojure_library and :clojure_test will be added to _every_ library and test generated by gen_build. Prefer ns metadata for per-ns additions

## Toolchains

Rules require `@rules_clojure//:toolchain` type.

Default is registered with `rules_clojure_toolchains` from [@rules_clojure//:repositories.bzl](repositories.bzl)

Custom toolchain can be defined with `clojure_toolchain` rule from [@rules_clojure//:toolchains.bzl](toolchains.bzl)

Please see [example](examples/setup/custom) of custom toolchain.

# Thanks

- Forked from https://github.com/simuons/rules_clojure
- Additional inspiration from https://github.com/markdingram/bazel-clojure
